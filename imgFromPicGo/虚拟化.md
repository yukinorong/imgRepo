## 虚拟化

### 抽象：进程

1. 进程的机器状态：内存、寄存器、持久存储。
2. 寄存器：程序计数器（program counter, PC, 也称 指令指针 Instruction pointer IP ）指向即将执行哪个指令，栈指针stack pointer、帧指针frame pointer 用来管理函数参数栈、局部变量、返回地址。
3. 分离高级“策略” 和 底层“机制”，形成模块化软件设计原则。
4. 进程API ： 创建、销毁、等待、其他控制、状态
5. 进程创建：OS将代码和静态数据加载到内存，为程序运行时的栈、堆分配内存，执行I/O相关任务。
6. 进程状态：运行、就绪、阻塞。
7. 数据结构：操作系统需要对进程上下文切换  
   进程列表 PCB

### 进程API

1. fork() 系统调用  
   在当前代码执行位置创建“分支”，复制当前父进程的内存创建子进程，并在此父子进程同时执行下去。子进程拥有自己的地址空间、寄存器、程序计数器。子进程的fork函数返回值是0， 父进程的fork() 返回子进程的pid。
2. wait() 系统调用  
   父进程可以调用wait()函数，使得子进程运行结束后再运行。
3. exec() 进程替换  
   调用exec()函数后元进程由新进程代换，不创建新进程，进程ID不改变，只是用新程序替换了当前进程的正文、数据、堆栈，源进程中已经打开的文件描述符，在新进程也将保持打开。  
   exec() 执行成功则不会返回。执行失败则会返回失败的信息，并继续执行。
4. 可以通过查看shell 的 man手册了解更多信息。

### 受限直接执行

#### 受限制的操作

1. 硬件提供不同的执行模式，来协助操作系统。在用户模式下，应用程序不能完全访问硬件资源，在内核模式下，操作系统可以访问机器的全部资源。提供了陷入、陷出和一些其他指令、让操作系统告诉硬件陷阱表在内存中的位置。
2. 执行陷入时，硬件必须确保存储有足够的调用者寄存器，以便操作系统陷出时可以正确返回，处理器会将程序计数器、标志、一些其他寄存器推送到每个进程的内核栈上，返回时会从栈中弹出。
3. 发起系统调用的过程不能指定要跳转的地址，这样将会让程序跳转到内核中的任意位置。内核也需要谨慎处理陷入后执行的代码。
4. 内核在启动时设置陷阱表，用来告诉硬件在发生某些异常事件是要运行某些代码。
5. 将陷阱表的位置告诉硬件的指令，也是一种特权指令。

#### 进程之间切换

当进程在CPU上运行时，操作系统没有在CPU上运行，那操作系统如何重新获取CPU的控制权

1. 协作方式：等待系统调用  
   友好的程序会在恰当的位置如打开文件时，会使用yield系统调用将控制转移给操作系统。
2. 非协作方式：操作系统进行控制  
   当进程出现除0，越界访问内存，死循环等违规操作时，进程无法自动跳出。  
   此时需要采用硬件的参与进行进程的中断：时钟中断。  
   操作系统预先配置中断处理程序，当时钟中断时，操作系统会获得CPU的控制权。  
   硬件发生中断时，需要给正在运行的进程保存足够的状态，保障下次运行时可以正常恢复。寄存器会被保存到内核栈中。
3. 保存和恢复上下文  
   **时间顺序：**  
   硬件：  
   1 触发时钟中断  
   2 将寄存器A保存到内核栈A  
   3 转换为内核模式 4 陷入  
   操作系统：  
   1 处理陷入  
   2 调用switch()例程（将寄存器A保存到进程结构A，将进程结构B恢复到寄存器B）  
   3 处理陷出  
   硬件：  
   1 从内核栈B恢复寄存器B  
   2 转换为用户模式  
   3 跳到B的程序计数器。
4. 并发问题  
   1. 如何解决正在处理

#### 进程调度

1. 调度指标：

2. T周转 = T 完成 - T 到达

3. T响应 = T首次运行 - T 到达

4. 调度策略：

5. 先进先出

6. 最短任务优先 SJF

7. 最短完成时间优先 STCF : 每个新任务可依据剩余工作时间进行抢占

8. 轮转 RR ：每个任务分配时间片，循环执行。（降低响应时间，但增加周转时间）

9. 重叠，结合IO：当A进程进行IO操作时，释放cpu运行B进程。

### 调度：多级反馈队列 MLFQ

1. 内部结构：

2. MLFQ具有许多独立的队列，每个队列有不同的优先级，

3. 队列内部的工作具有相同的优先级，对这些工作采用轮转调度。

4. 基本规则：

5. 优先运行优先级高的进程

6. 优先级相等，则轮转运行

7. 工作进入系统时，放在最高优先级

8. 一旦工作完成了某一层的时间配额，（无论中间放弃了多少次CPU）就降低其优先级。

9. 每经过一段时间S，就将系统中所有工作重新加入最高优先级队列。

10. 一些补充

11. 避免巫毒常量（经过时间S 将工作加入最高优先级，此处如果S太高，会导致长工作饥饿，S太低，会导致交互性工作得不到合适的CPU时间比例。）  
    如何避免，可以让系统自行学习一个可优化的值，或设置默认值。

12. 从优先级高到低，时间片逐步提升。

### 调度：比例份额

1. 通过给每个进程一定的份额，通过“抽奖”的方式，选择进程运行，只需要设定好每个进程拥有的“彩票”数量，即可完成调度。

2. 随机性：

3. 较好的处理边角情况

4. 轻量，不需要记录任何状态，只需设定进程的份额，**相比于其他策略不需要全局状态**

5. 随机方法很快，适用于运行速度要求高的场景。

6. 步长策略：

7. 每个工作拥有自己的步长和行程值，步长为一个大数除以彩票数量（即步长之比为彩票数量的反比），行程值默认为0，

8. 每次调度系统选择最短的行程值进程运行，相同时采用随机策略，这样使得概率上每个进程的运行次数都吻合。

### 多处理器调度

### 抽象：地址空间

1. os需要提供一个易用的物理内存抽象，这被叫做地址空间。

2. 地址空间包含所运行程序的所有内存状态，如程序代码，堆，栈。堆从低地址向高，栈从高地址向低。

3. 虚拟化内存：os在物理内存上为每个运行的进程，构建一个私有的、可能地址空间很大的抽象。  
   目标：

4. 透明：操作系统实现虚拟化内存的方式不应该被进程感知。

5. 效率：os应当追求虚拟化尽可能的在时间上、空间上高效。需要依赖硬件支持。

6. 保护：确保一个进程在运行时

### 内存操作API

1. 内存类型：

2. 栈内存：可以直接通过声明变量申请，在函数退出时自动释放。

3. 堆内存：通过malloc申请。

4. malloc ：void *malloc(size_t size); 传入的size 可用 sizeof计算，如果是字符串可以用malloc(strlen(s) +1)

5. free : free接收一个地址释放堆内存，分配区域的大小由内存分配库本身记录追踪。

6. strdup() 函数： 区别于 strcpy() ，strdup会在字符串复制前，先给变量申请和被复制字符串一样大小的内存。

7. 两级内存管理：

8. 进程执行的内存管理：调用malloc和free在堆内管理。

9. OS执行的内存管理，在进程运行时将内存交给进程，在进程退出时将其回收。所以即使是短时间运行的进程出现了内存泄漏，往往不会有较大的影响，因为在进程退出时无论地址空间中堆的状态如何，OS会回收所有页面。  
   但如果是一个长期运行的服务器发生了内存泄漏，这可能会逐步扩大，最终在内存不足时崩溃。  
   更为严重的是操作系统本身存在泄露内存。

10. 内存问题检测工具：**purify, valgrind** ！！

11. 其他的c语言库函数：

12. mmap() 从操作系统获取内存，在程序中创建一个匿名内存区域（不与任何特定文件相关联，只与交换空间swap space相关联）

13. calloc 分配内存并在返回前置零

14. realloc 创建一个更大的内存区域，将旧区域复制到其中。

## 并发
